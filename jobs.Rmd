---
title: "Data Related jobs"
author: "Khuong Le & Shiyong Liu"
date: July 23, 2018
---

Load different packages that will use in this model:

```{r}
pkg_list = c("ggplot2", "plyr", "stringr")
mia_pkgs = pkg_list[!(pkg_list %in% installed.packages()[,"Package"])]
if(length(mia_pkgs) > 0) install.packages(mia_pkgs)
loaded_pkgs = lapply(pkg_list, require, character.only=TRUE)
```

Set up the data:

```{r}
jdata = read.csv("datarelatedjobs.csv")
jdata$X = NULL
names(jdata)
summary(jdata)
str(jdata)
```

Transform the data.

```{r}
jdata$Preferred_mj1 = as.character(jdata$Preferred_mj1)
jdata$Preferred_mj2 = as.character(jdata$Preferred_mj2)

for(i in 1:length(jdata$Standing)){
  if(is.na(jdata$Standing[i])){
    jdata$Standing[i] = "All levels"
  }
} 
for(i in 1:length(jdata$Preferred_mj1)){
  if(is.na(jdata$Preferred_mj1[i])){
    jdata$Preferred_mj1[i] = "Data_related"
  }  
  if(is.na(jdata$Preferred_mj2[i])){
      jdata$Preferred_mj2[i] = "Data_related"
  }
} 
count(jdata$Preferred_mj2)[order(count(jdata$Preferred_mj2)$freq, decreasing = T),]
head(jdata,10)
```

1. Comparing between companies in the North and the South of California (using side-by-side histogram):

- Number of Cities.
- Number of companies in North vs South
- Average minimum experience. 
- Average salary in North vs South

Set up number of cities.

```{r}
ct_City = count(jdata$City)
topCity = ct_City[order(ct_City$freq, decreasing = T),]

tCitydf = data.frame(City_Name =  c("S.Francisco" , "L.Angeles" , "S.Jose" , "M.View" , "S.Diego", "S.Mateo" , "P.Alto", "S.Monica", "Sunnyvale" , "RedwoodCity"),
                     NumberofPosition = c(topCity$freq[1:10]))

city_plot = ggplot(data = tCitydf, aes(x = City_Name, y = NumberofPosition)) + 
    geom_bar(stat = "identity", position=position_dodge()) 
city_plot
```

Set up 2 subsets for North and South:

```{r}
North_sub = jdata[which(jdata$Region == "North CA"),]
head(North_sub,5)
South_sub = jdata[which(jdata$Region == "South CA"),]
head(South_sub,5)
```

Number of companies:

```{r}
n_companies_north = rep(0, length(count(North_sub$Company)$freq))
n_companies_south = rep(0, length(count(South_sub$Company)$freq))

for(i in 1:length(count(North_sub$Company)$freq)){
  if(count(North_sub$Company)$freq[i] == 1){
    n_companies_north[i] = count(North_sub$Company)$freq[i] 
  } else{
    n_companies_north[i] = 1
  }
}

for(i in 1:length(count(South_sub$Company)$freq)){
  if(count(South_sub$Company)$freq[i] == 1){
    n_companies_south[i] = count(South_sub$Company)$freq[i] 
  } else{
    n_companies_south[i] = 1
  }
}
sum(n_companies_north)
sum(n_companies_south)
```

Average minimum experience:

```{r}
avg_exp_N = round(mean(North_sub$Min_exp)*12,0)
avg_exp_S = round(mean(South_sub$Min_exp)*12,0)
avg_exp_N
avg_exp_S
```
 
Average salary:

```{r}
#Use NA.omit to omit to take out NA values then use mean function to find average
Omit_yr_salary_N = na.omit(North_sub$Est_min_avg_salary)
Omit_yr_salary_S = na.omit(South_sub$Est_min_avg_salary)
North_Est_min_salary = round(mean(Omit_yr_salary_N)/1000,2)
South_Est_min_salary = round(mean(Omit_yr_salary_S)/1000,2)

North_Est_min_salary
South_Est_min_salary
```

Setting up the dataframe for histogram:

```{r}
firstdf = data.frame(
          Region = rep(c("North", "South"), each = 3),
          Factor = rep(c("Average experience (in months)", "Average salary (in thousands)","Number Companies")),
          Number = c(avg_exp_N, North_Est_min_salary, sum(n_companies_north),
                     avg_exp_S, South_Est_min_salary, sum(n_companies_south)))

plotfirst = ggplot(data = firstdf, aes(x = Factor, y = Number, fill = Region)) + 
    geom_bar(stat = "identity", position=position_dodge()) +  
    geom_text(aes(label = Number), position = position_dodge(0.95), vjust=0.5, color = "darkred", size = 3)

#jpeg('plotfirst.jpg')
#plot(plotfirst)
plotfirst

```

2. Comparing between companies in the North and the South of California (using side-by-side histogram):
- Number of Bachelor's, Master's, Ph.D that companies recruiting in North vs South. (All levels = add 1 to every value)
- Top 5 most used languages.
- Top 5 major needs.

```{r}
#Nearly same as counting number of companies:
#Create 3 vectors: n_bach, n_master, n_phd to store the values.
#For this one we need to use stringr.
#Ex: All levels -> n_bach = n_bach + 1, n_master = n_master + 1, n_phd = n_phd + 1
#BS/MS ->  n_bach = n_bach + 1, n_master = n_master + 1 (Use  stringr so that we can get only BS or only MS)
Standing_sub = jdata[which(jdata$Standing != "NA"),]
North_sub_st = Standing_sub[which(Standing_sub$Region == "North CA"),]
South_sub_st = Standing_sub[which(Standing_sub$Region == "South CA"),]
```

String R, numbers of standing South:

```{r}
n_bach_S = length(str_subset(South_sub_st$Standing, pattern = "^B")) + count(South_sub_st$Standing)$freq[which(count(South_sub_st$Standing) == "All levels")]  
n_bach_S

n_master_S = length(str_subset(South_sub_st$Standing, pattern = "^MS")) + length(str_subset(South_sub_st$Standing, pattern = "MS$")) + count(South_sub_st$Standing)$freq[which(count(South_sub_st$Standing) == "All levels")] - length(str_subset(South_sub_st$Standing, pattern = "^MS$"))
n_master_S

n_PH.D_S = length(str_subset(South_sub_st$standing, pattern = "^PH.D")) + length(str_subset(South_sub_st$Standing, pattern = "PH.D$")) + count(South_sub_st$Standing)$freq[which(count(South_sub_st$Standing) == "All levels")]
n_PH.D_S
```

String R, numbers of standing North:

```{r}
n_bach_N = length(str_subset(North_sub_st$Standing, pattern = "^B")) + count(North_sub_st$Standing)$freq[which(count(North_sub_st$Standing) == "All levels")]  
n_bach_N

n_master_N = length(str_subset(North_sub_st$Standing, pattern = "^MS")) + length(str_subset(North_sub_st$Standing, pattern = "MS$")) + count(North_sub_st$Standing)$freq[which(count(North_sub_st$Standing) == "All levels")] - length(str_subset(North_sub_st$Standing, pattern = "^MS$"))
n_master_N

n_PH.D_N = length(str_subset(North_sub_st$standing, pattern = "^PH.D")) + length(str_subset(North_sub_st$Standing, pattern = "PH.D$")) + count(North_sub_st$Standing)$freq[which(count(North_sub_st$Standing) == "All levels")]
n_PH.D_N
```

Create dataframe to plot out our histogram:

```{r}
secondtdf = data.frame(
          Region = rep(c("North", "South"), each = 3),
          Factor = rep(c("Bachelor degree", "Master degree","PH.D")),
          Number = c(n_bach_N, n_master_N, n_PH.D_N,
                     n_bach_S, n_master_S, n_PH.D_S))

plotsecond = ggplot(data = secondtdf, aes(x = Factor, y = Number, fill = Region)) + 
    geom_bar(stat = "identity", position=position_dodge()) +  
    geom_text(aes(label = Number), position = position_dodge(0.95), vjust=0.5, color = "darkred", size = 3)

#jpeg('plotsecond.jpg')
#plot(plotsecond)
plotsecond
```

Write function to count and put them in decreasing order:

Intputs: 2 columns that needs to be counted
Output: Dataframe in order of your choice (decreasing/ increasing)

```{r}
count_order = function(col1, col2, order, top){
  ct1 = count(col1)
  ct2 = count(col2)
  if(order == "decreasing"){
    ct1_inc = ct1[order(ct1$freq, decreasing = T),]
    ct2_inc = ct2[order(ct2$freq, decreasing = T),]
    
    cl = length(ct1_inc$freq) - length(ct2_inc$freq)

    if(cl < 0){
      fresult = data.frame(Lang1 = c(as.character(ct1_inc$x), rep(NA,abs(cl))),
                            Freq1 = c(ct1_inc$freq, rep(NA,abs(cl))),
                            Lang2 = as.character(ct2_inc$x),
                            Freq2 = ct2_inc$freq)                  

    } else{
      fresult = data.frame(Lang1 = as.character(ct1_inc$x),
                            Freq1 = ct1_inc$freq,
                            Lang2 = c(as.character(ct2_inc$x), rep(NA,cl)),
                            Freq2 = c(ct2_inc$freq,rep(NA,cl)))         
      }
  }
  else{
    ct1_dec = ct1[order(ct1$freq, decreasing = F),]
    ct2_dec = ct2[order(ct2$freq, decreasing = F),]
    
    cl = length(ct1_dec$freq) - length(ct2_dec$freq)

    if(cl < 0){
      fresult = data.frame(Lang1 = c(as.character(ct1_dec$x), rep(NA,abs(cl))),
                            Freq1 = c(ct1_dec$freq, rep(NA,abs(cl))),
                            Lang2 = as.character(ct2_dec$x),
                            Freq2 = ct2_dec$freq)                  
    } else{
      fresult = data.frame(Lang1 = as.character(ct1_dec$x),
                            Freq1 = ct1_dec$freq,
                            Lang2 = c(as.character(ct2_dec$x), rep(NA,cl)),
                            Freq2 = c(ct2_dec$freq,rep(NA,cl))) 
    }
  }
  for(i in 1:15){
    for(j in 1:15){
      if(fresult$Lang1[i] == fresult$Lang2[j]){
        fresult$Freq1[i] = fresult$Freq1[i] + fresult$Freq2[j]
      }
    }
  }
  if(order == "decreasing"){
    res = fresult[order(fresult$Freq1, decreasing = T),]
  } else {
    res = fresult[order(fresult$Freq1, decreasing = F),]
  }
  return(res[1:top,1:2])
}


```

Plot a histogram to see the prefer language for both prefer language 1 and prefer language 2
Dataframe for counting Language:

```{r}
sl = count_order(South_sub_st$Preferred_lang1, South_sub_st$Preferred_lang2,"decreasing", 5)
nl = count_order(North_sub_st$Preferred_lang1, North_sub_st$Preferred_lang2,"decreasing", 5)
sl
nl
thirddf = data.frame(
          Region = rep(c("North", "South"), each = 5),
          Factor = rep(c("SQL", "Python", "R", "Java", "Tableau - C/C++"),2),
          Number = c(nl$Freq1[1], nl$Freq1[2], nl$Freq1[3], nl$Freq1[4], nl$Freq1[5], 
                     sl$Freq1[1], sl$Freq1[2], sl$Freq1[3], sl$Freq1[4], sl$Freq1[5]))

plotthird = ggplot(data = thirddf, aes(x = Factor, y = Number, fill = Region)) + 
    geom_bar(stat = "identity", position=position_dodge()) +  
    geom_text(aes(label = Number), position = position_dodge(0.95), vjust=0.5, color = "darkred", size = 3)

#jpeg('plotsecond.jpg')
#plot(plotsecond)
plotthird
```

Calculate Language in different way to double check:

```{r}
n_cpp_North = length(str_subset(North_sub_st$Preferred_lang1, pattern = "^C\\++$")) +length(str_subset(North_sub_st$Preferred_lang2, pattern = "C\\++$"))

n_cpp_South = length(str_subset(South_sub_st$Preferred_lang1, pattern = "^C\\++$")) +length(str_subset(South_sub_st$Preferred_lang2, pattern = "C\\++$"))

n_java_South = length(str_subset(South_sub_st$Preferred_lang1, pattern = "^Java$")) +length(str_subset(South_sub_st$Preferred_lang2, pattern = "^Java$"))

n_java_North = length(str_subset(North_sub_st$Preferred_lang1, pattern = "^Java$")) +length(str_subset(North_sub_st$Preferred_lang2, pattern = "^Java$"))

n_Python_North = length(str_subset(North_sub_st$Preferred_lang1, pattern = "^Python$"))+length(str_subset(North_sub_st$Preferred_lang2, pattern = "^Python$"))

n_Python_South = length(str_subset(South_sub_st$Preferred_lang1, pattern = "^Python$"))  +length(str_subset(South_sub_st$Preferred_lang2, pattern ="^Python$"))

n_R_North = length(str_subset(North_sub_st$Preferred_lang1, pattern = "^R$")) +length(str_subset(North_sub_st$Preferred_lang2, pattern = "R$"))

n_R_South = length(str_subset(South_sub_st$Preferred_lang1, pattern = "^R$"))  +length(str_subset(South_sub_st$Preferred_lang2, pattern = "R$"))
n_R_South
n_SQL_North = length(str_subset(North_sub_st$Preferred_lang1, pattern = "^SQL$")) +length(str_subset(North_sub_st$Preferred_lang1, pattern = "/SQL$")) +length(str_subset(North_sub_st$Preferred_lang2, pattern = "^SQL$"))

n_SQL_South = length(str_subset(South_sub_st$Preferred_lang1, pattern = "^SQL$"))+ length(str_subset(South_sub_st$Preferred_lang1, pattern = "/SQL$"))+ length(str_subset(South_sub_st$Preferred_lang2, pattern = "^SQL$"))


res = cbind(nl,sl)
handwaydf = data.frame(NLang1 = c("SQL", "Python", "R", "Java", "C/C++"),
                       NFreg1 = c(n_SQL_North, n_Python_North, n_R_North, n_java_North, n_cpp_North),
                       SLang1 = c("SQL", "Python", "R", "Java", "C/C++"),
                       NLang1 = c(n_SQL_South, n_Python_South, n_R_South, n_java_South, n_cpp_South))
res
handwaydf
```

Plot a histogram to see the prefer major for both prefer major 1 and prefer major 2
Dataframe for counting Major:


```{r}
smj = count_order(South_sub_st$Preferred_mj1, South_sub_st$Preferred_mj2,"decreasing", 5)
nmj = count_order(North_sub_st$Preferred_mj1, North_sub_st$Preferred_mj2,"decreasing", 5)
smj
nmj
forthdf = data.frame(
          Region = rep(c("North", "South"), each = 5),
          Factor = rep(c("CS", "Tech field - Stats", "Stats - Tech field", "Math", "Engineering"),2), 
          Number = c(nmj$Freq1[1], nmj$Freq1[2], nmj$Freq1[3], nmj$Freq1[4], nmj$Freq1[5], 
                     smj$Freq1[1], smj$Freq1[2], smj$Freq1[3], smj$Freq1[4], smj$Freq1[5]))

plotforth = ggplot(data = forthdf, aes(x = Factor, y = Number, fill = Region)) + 
    geom_bar(stat = "identity", position=position_dodge()) +  
    geom_text(aes(label = Number), position = position_dodge(0.95), vjust=0.5, color = "darkred", size = 3)

#jpeg('plotsecond.jpg')
#plot(plotsecond)
plotforth


```

Plot a histogram to see the prefer major for both prefer major 1 and prefer major 2
Dataframe for counting Major:

3 - Write function to find out suitable companies: "find_company" that has 4 agrument. Minimum standing, experience, region, best language. It will return the dataframe that has all the company that fit our agruments

Let's just use the top 20 preferred language:

```{r}
top20 = count_order(jdata$Preferred_lang1, jdata$Preferred_lang2,"decreasing", 20)
top20
```

Change the data in the way that if "Bachelor"/"All levels" is able to be looked at means Easy, "Master" means Medium and "PHD" will be Hard.

Our function will now base on Difficulty, Experience, Region, Best Language:


```{r}
for (i in 1:length(jdata$Standing)){
  if(!is.na(str_extract(jdata$Standing[i], pattern = "^B")) || !is.na(str_extract(jdata$Standing[i], pattern = "^A"))){
    jdata$Difficulty[i] = "Easy"
  } else if (!is.na(str_extract(jdata$Standing[i], pattern = "^M"))){
    jdata$Difficulty[i] = "Medium"
  } else if (!is.na(str_extract(jdata$Standing[i], pattern = "^P"))){
    jdata$Difficulty[i] = "Hard"
  }
}
```

Function find_company using intersect and union subsets.

```{r}
find_company = function(Difficulty, Exp, Region,Language){
  Argu_y = jdata$Company[which(jdata$Difficulty == Difficulty)]
  Argu_x = jdata$Company[which(jdata$Min_exp <= Exp)]
  Argu_z = jdata$Company[which(jdata$Region == Region)]
  Argu_u1 = jdata$Company[which(jdata$Preferred_lang1 == Language)]
  Argu_u2 = jdata$Company[which(jdata$Preferred_lang2 == Language)]
  
  return(union(intersect(intersect(Argu_x,Argu_y),intersect(Argu_z,Argu_u1)),intersect(intersect(Argu_x,Argu_y),intersect(Argu_z,Argu_u2))))

}

find_company("Medium", 5, "South CA","R")
```

Another way using subset find_company:

```{r}
n_find_company = function(Difficulty, Exp, Region,Language){
a = jdata$Company[which(jdata$Difficulty == Difficulty),]
b = jdata$Company[which(jdata$Min_exp <= Exp),]
c = jdata$Company[which(jdata$Region == Region),]
d1 = jdata$Company[which(jdata$Preferred_lang1 == Language),]
d2 = jdata$Company[which(jdata$Preferred_lang2 == Language),]

pre_r1 = a[which(a$Min_exp <= Exp)]
nex_r1 = pre_r1[which(pre_r1$Region == Region)]
r1     = nex_r1[which(nex_r1$Preferred_lang1 == Language)]

pre_r2 = a[which(a$Min_exp <= Exp)]
nex_r2 = pre_r2[which(pre_r2$Region == Region)]
r2     = nex_r2[which(nex_r2$Preferred_lang2 == Language)]

rbind(r1,r2)
}
find_company("Medium", 5, "South CA","R")
```

4 - Linear regression model to find our salary and check if it fit.

Data transformation:
Minimum experience

```{r}
for(i in 1:length(jdata$Min_exp)){
  if(jdata$Min_exp[i] == 1 & !is.na(jdata$Est_min_avg_salary[i])){
    if(jdata$Est_min_avg_salary[i] >= 150000){
      jdata$Min_exp[i] = 4
    }
    else if(jdata$Est_min_avg_salary[i] >= 130000 &
            jdata$Est_min_avg_salary[i] <  150000){
      jdata$Min_exp[i] = 3
    }
    else if (jdata$Est_min_avg_salary[i] >= 100000 &
             jdata$Est_min_avg_salary[i] <  130000){
      jdata$Min_exp[i] = 2
    }
    else{jdata$Min_exp[i] = 1}
  } 
}
```

Add variable names: Jobs density to show which city offers lots of position, which city offers less position.

```{r}
set.seed(2018)
result = jdata$Est_min_avg_salary[which.min(jdata$Est_min_avg_salary)]
for (i in 1:length(jdata$City))
if(count(jdata$City)$freq[which(count(jdata$City)$x == (jdata$City[i]))] > mean(count(jdata$City)$freq)){ 
  jdata$Jobs_density[i] = "High"
  jdata$City_Bonus[i] = round(rnorm(1, mean = result * 1.5, sd = 1500),1) 
} else {
  jdata$Jobs_density[i] = "Low"
  jdata$City_Bonus[i] = round(rnorm(1, mean = result * 1.45, sd = 1500),1) 
}
```

Set up bonuses for salary:

According to job function, we can divide position into 3 functions (Engineer, Scientist, Analyst). Assume bonuses follow a normal distribution that has mean = 7000 - 6000 - 5000 and sd = 500

```{r}
set.seed(2018)
for (i in 1:length(jdata$Position)){
  if(str_detect(jdata$Position[i], pattern = "Engineer")){
    jdata$Posi_Bonus[i] = round(rnorm(1, mean = 25000, sd = 1000),1)
  }  else if (str_detect(jdata$Position[i], pattern = "Scientist")){
    jdata$Posi_Bonus[i] = round(rnorm(1, mean = 22000, sd = 1000),1)
  }  else if (str_detect(jdata$Position[i], pattern = "Analyst")){
    jdata$Posi_Bonus[i] = round(rnorm(1, mean = 15000, sd = 1000),1)
  } else {
    jdata$Posi_Bonus[i] = round(rnorm(1, mean = 10000, sd = 1000),1)
  }
}

```

Finding bonuses for with the year of experience:

```{r}
calc_salary = na.omit(jdata$Est_min_avg_salary)
avg_salary = mean(calc_salary[which(calc_salary >= 100000)])
salaryvsyear = lm(Est_min_avg_salary ~ Min_exp, data = jdata)
summary(salaryvsyear)
#Since the p-value for this model is very small it looks like the Min_exp is significant.
exp_multiplier = summary(salaryvsyear)$coef[2,1]
```

Set up bonus for Bonuses with years experience

```{r}
set.seed(2018)
for (i in 1:length(jdata$Min_exp)){
  if(is.na(jdata$Est_min_avg_salary[i])){
    jdata$Exp_Bonus[i] = round(exp_multiplier * jdata$Min_exp[i] / mean(jdata$Min_exp) ,1) 
  }  else if(!is.na(jdata$Est_min_avg_salary[i]) & jdata$Est_min_avg_salary[i] >= 100000){
    jdata$Exp_Bonus[i] = round(exp_multiplier * jdata$Min_exp[i] ,1) 
  }  else {
    jdata$Exp_Bonus[i] = round(exp_multiplier * jdata$Min_exp[i] /2 ,1) 
  }
}
head(jdata,50)

```

Original model:

```{r}
par(mfrow = c(1,3))
model1 = lm(Est_min_avg_salary ~ City_Bonus, data = jdata)
plot(jdata$Est_min_avg_salary ~ jdata$City_Bonus, main = "Salary vs City Bonus", xlab = "City Bonus", ylab = "Salary")
abline(model1)

model2 = lm(Est_min_avg_salary ~ Posi_Bonus, data = jdata)
plot(jdata$Est_min_avg_salary ~ jdata$Posi_Bonus, main = "Salary vs Position Bonus", xlab = "Position Bonus", ylab = "Salary")
abline(model2)

model3 = lm(Est_min_avg_salary ~ Exp_Bonus, data = jdata)
plot(jdata$Est_min_avg_salary ~ jdata$Exp_Bonus, main = "Salary vs Experience Bonus", xlab = "Experience Bonus", ylab = "Salary")
abline(model3)
```

New model:

```{r, warning = FALSE}
fit_model = lm(Est_min_avg_salary ~ Min_exp + Est_min_avg_salary + Exp_Bonus + City_Bonus + Posi_Bonus, data = jdata)
summary(fit_model)
```

Logistic Regression model:

Set up logistic model. 
```{r}
for(i in 1:length(jdata$Region)){
  if(jdata$Region[i] == "North CA"){
    jdata$Region_Logic[i] = 1
  } else { 
    jdata$Region_Logic[i] = 0
  }
}
head(jdata,50)

```

The model:
```{r}
fit_glm = glm(Region_Logic ~ Est_min_avg_salary, data = jdata, family = binomial(link = "logit"))
fit_lm  = 

plot(Region_Logic ~ Est_min_avg_salary, data = jdata, pch = 20, ylab = "Estimated Probability",   main = "Ordinary vs Logistic Regression")
grid()

abline(fit_lm, col = "darkorange")
curve(predict(fit_glm, data.frame(Est_min_avg_salary), type = "response"), 
      add = TRUE, col = "dodgerblue", lty = 2)
legend("topleft", c("Ordinary", "Logistic", "Data"), lty = c(1, 2, 0), 
       pch = c(NA, NA, 20), lwd = 2, col = c("darkorange", "dodgerblue", "black"))
```

Report:
Introduction: What is this project about? Why do we do this? 
Body: Talk about all of the graphs we have.
- What's the graph about.
- Why do we make this graph
- Interesting number, reasons?
Talk about those functions we made

Conclusion: Talk about the benefits of making this project.


